# TicTacToe-AI-Minimax
This project implements a TicTacToe AI that implements a 7-layer minimax algorithm to actively choose its play strategy based on the current game state. It's designed to run with polynomial time, and it relies on its pre-defined prediction metrics to continually refine its approximation of what the optimal solution would be.

The rough algorithm works as follows (a pretty good description with diagrams can also be found on the website NeverStopBuilding, found [here](https://www.neverstopbuilding.com/blog/2013/12/13/tic-tac-toe-understanding-the-minimax-algorithm13))
1. Before the game begins: we define a cost metric function that takes in a board state and returns a number measuring whether the player has a high chance to win (i.e. it returns a large positive number), whether the computer has a high chance to win (i.e. it returns a large negative number), or whether the game will end in a time (i.e. it returns a number close to 0). 
2. During the game itself: once the player's turn ends, the computer first figures out all the possible moves it can make in its move. Then, for each move, it figures out what possible moves can the player make to counteract that move. This process continues until the 7th level (it ends on the computer's turn), which is when the minimax algorithm begins. Given the possible moves that the computer can make on the 7th level, a pre-defined cost function predicts the chance that the computer will win given that it makes each move. The computer will then pick the possible move on that level that minimizes its cost prediction (i.e. gives it the greatest chance to win). Thus, this is called the "min" stage of the minimax algorithm.
3. Once we find the best computer move on all the possible 7th level configurations, we return to the 6th level. The 6th level, which models the perspective that the player would have when seeing the board, would want to maximize his possible score assuming the computer was playing optimally. Thus, he would pick the option among all the optimal 7th level configurations that would give the maximal score (i.e. make it most likely for him to win). This is why this is called the "max" stage of the minimax algorithm.
4. This process continues recursively until we reach the 1st stage, or the current board configuration, where the computer selects the possible move option that would minimize its possible score (or, if it helps to think of it this way, it selects the move that would make it the hardest for the player to win). This recursive process is implemented largely in the `Game.java` class.
   
Note that this code makes a few improvements on the traditional minimax algorithm to optimize its space and time performance and to improve the playing experience:
* Store previous board configurations in a HashMap to improve lookup time for subsequent moves (this decreased our lookup time to about 30% of the original value in the first turn and to about 7% of the original value in subsequent turns)
* Analyze all possible moves to determine optimal move to cut player off (minimizes the chance of losses or draws, even if the computer hadn't been playing optimally after that move). We previously also tried adding alpha-beta pruning to reduce our time consumption in return for a more approximate measure of move optimality, but we noticed no significant improvement and even found a slight overhead delay, most likely because the scale of a TicTacToe game didn't warrant the additional complexity of alpha-beta pruning.
* When placed into a position of certain defeat, the algorithm chooses the move that would prolong the game

To analyze the time and space complexity of the algorithm, let d be the size of the board (so there are d^2 squares on a board of size d). Because each layer requires, in the worst case, `O(d^2)` possible move options, the 7-layer minimax algorithm has a time complexity of `O(d^14)`. However, in practice for a standard TicTacToe game, `d` is relatively small so a more accurate measure would be more applicable, such as `O(d^14-21d^12)`. This gives relatively fast performance for small `d` (for example, d = 3 requires about 181,000 moves to check in the 7-layer minimax algorithm, which even without the performance improvements mentioned above would take less than half a second on most modern consumer computers). Because this algorithm maintains a HashMap saving board configurations for fast access, the space consumption is `O((d^2)!(d^2))` in the worst case, but again for TicTacToe this rarely ever happens or is a problem.
